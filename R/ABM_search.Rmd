---
title: "Asymetric Brownian Motion (ABM)"
author: "Théo Gaboriau"
date: "27 11 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```



## ABM conditions to match


This presents the conditions that have to be matched for the inheritance of traits variance (range) during speciation.
Lets call $V_a$ the variance of the ancestor at $t = T_s$ and $V_1, V_2$ the variance of its descendants at $t = T_s$.

```{r}
plot.new()
plot.window(xlim = c(1, 10), ylim = c(1, 10))
segments(c(2,5.1,5.1), c(5,5.2,4.8), c(4.9, 8, 8), c(5, 8.1, 1.9))
points(c(4.9,5.1,5.1),c(5,5.2,4.8),pch = 16,cex = 1)
text(c(4.7,5.1,5.1),c(5,5.2,4.8),labels = c(expression(V[a]), expression(V[1]), expression(V[2])),pos = c(3,3,1))
axis(1, at = c(2,5,8), labels = c(expression(T[a]), expression(T[s]), 0))

```


First, each variance has to be strictly positive:

**condition 1:** $V_a > 0$, $V_1 > 0$ and $V_2 > 0$


Second, the ancestral variance has to be conserved:

**condition 2:** $V_a ≤ V_1 + V_2 ≤ 2V_a$


Ideally, we should allow the parametrization to meet a simple Brownian motion such as:

$V_a = V_1 = V_2$



## Latest try


We consider a parameter controling the bigger amount of variance inherited by one the descendants:

$\rho = \frac{V_2}{V_a}$ with $0 < \rho ≤ 1$ and $V_1 ≤ V_2$.


We consider another parameter controling the difference between the amount of inherited variance by descendants:

$\delta = \frac{V_1}{V_2}$ with $0 < \delta ≤ 1$.


With that parametrization only **condition 1** is met. We have a simple BM ($V_a = V_1 = V_2$) with $\rho = 1$ and 
$\delta = 1$



### example with $V_a = 5$

```{r}
v1 <- function(rho, delta, Va){
  return(rho*delta*Va)
}
v2 <- function(rho, delta, Va){
  return(rho*Va)
}

colvec <- colorRampPalette(rev(c("#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4",
                              "#88ddaa", "#66c2a5", "#37b69b", "#3288bd", "#71acbc")))(101)
rhos <- seq(1e-3, 1, length = 100)
deltas <- seq(1e-3, 1, length = 100)
Va <- 5
out_v1 <- matrix(NA, 100, 100)
dimnames(out_v1) <- list(rhos, deltas)
out_v2 <- matrix(NA, 100, 100)
dimnames(out_v2) <- list(rhos, deltas)

for(i in 1:100){
rho <- rhos[i]
out_v1[i,] <- v1(rho, deltas, Va)
out_v2[i,] <- v2(rho, deltas, Va)
}

layout(t(1:2))
par(mar = c(10,5,5,1), las = 1)
plot(rep(rhos, times = 100), rep(deltas, each = 100), pch = 15, col = colvec[round(out_v1/max(c(out_v1, out_v2))*100)+1],
     main = expression(paste("Effect of ", rho, " and ", delta, " on ", v[1])), xlab = expression(rho), ylab = expression(delta)) 
hist(out_v1, main = expression(V[1]),breaks = seq(min(out_v1),max(out_v1), length = 100), col = colvec, border = NA, xlab = expression(V[1]))


plot(rep(rhos, times = 100), rep(deltas, each = 100), pch = 15, col = colvec[round(out_v2/max(c(out_v1, out_v2))*100)+1],
     main = expression(paste("Effect of ", rho, " and ", delta, " on ", v[2])), xlab = expression(rho), ylab = expression(delta))
hist(out_v2, main = expression(V[2]),breaks = seq(min(out_v2),max(out_v2), length = 100), col = colvec, border = NA, xlab = expression(V[2]))


plot(rep(rhos, times = 100), rep(deltas, each = 100), pch = 15, col = colvec[round((out_v1+out_v2)/max((out_v1+ out_v2))*100)+1],
     main = expression(paste("Effect of ", rho, " and ", delta, " on ", v[1] + v[2])), xlab = expression(rho), ylab = expression(delta)) 
hist(out_v1 + out_v2, main = expression(V[1]+V[2]), breaks = seq(min(out_v1 + out_v2),max(out_v1 + out_v2), length = 100), col = colvec, border = NA, xlab = expression(V[1] + V[2]))




```


